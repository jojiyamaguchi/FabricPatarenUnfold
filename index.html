<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Drawing and Rotation</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <style>
        canvas {
            border: 1px solid black;
            width: 100%;
            height: 80vh;
        }
        .canvas-box {
            margin-bottom: 20px;
        }
        .button-group {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
        }
        .button-group button {
            margin: 0 5px;
        }
    </style>
</head>
<body>
    <div id="drawingCanvasBox" class="canvas-box">
        <canvas id="drawingCanvas"></canvas>
        <div class="button-group">
            <button id="rotateXPositiveButton">↓回転</button>
            <button id="rotateXNegativeButton">↑回転</button>
            <div id="xRotationAngle">X回転角: 0度</div>
            <button id="rotateYNegativeButton">←回転</button>
            <button id="rotateYPositiveButton">→回転</button>
            <div id="yRotationAngle">Y回転角: 0度</div>
        </div>
        <div class="button-group">
            <button id="resetButton">線を書き直す</button>
            <div id="lineLength">線の長さ: 0px</div>
            <button id="mirrorSymmetryResetButton">対称線リセット</button>
            <button id="unfoldButton">展開図作成</button>
            許容角度<input type="number" id="toleranceAngle" value="30">
        </div>
    </div>
    <div id="unfoldCanvasBox" class="canvas-box">
        <canvas id="unfoldCanvas" width="500" height="500"></canvas>
        <div class="button-group">
            <button id="unfoldRotateXPositiveButton">↓回転</button>
            <button id="unfoldRotateXNegativeButton">↑回転</button>
            <div id="unfoldXRotationAngle">X回転角: 0度</div>
            <button id="unfoldRotateYNegativeButton">←回転</button>
            <button id="unfoldRotateYPositiveButton">→回転</button>
            <div id="unfoldYRotationAngle">Y回転角: 0度</div>
        </div>
    </div>

    <script>
        const drawingCanvas = document.getElementById('drawingCanvas');
        const drawingContext = drawingCanvas.getContext('2d');
        const centerX = drawingCanvas.width / 2;
        const centerY = drawingCanvas.height / 2;

        const unfoldCanvas = document.getElementById('unfoldCanvas');
        const unfoldContext = unfoldCanvas.getContext('2d');
        const unfoldCenterX = unfoldCanvas.width / 2;
        const unfoldCenterY = unfoldCanvas.height / 2;

        let isDrawing = false;
        let points = [];
        let angleX = 0;
        let angleY = 0;
        let unfoldAngleX = 0;
        let unfoldAngleY = 0;
        let currentLine = [];
        let draggedPoint = null;
        let draggedMirrorPoint = null;
        let draggedCenterPoint = null;
        let lastPoint = null;
        let mirrorPoints = [];
        let centerPoint = null;
        let unfoldCenterPoint = null;
        let unfoldCenterPointClass = null;
        let combinedPoints = [];
        let combinedPointsClass = [];
        let surfaceDisplay = false;
        let lineBreak = false;

        class Point {
            constructor(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
        }

        class UnfoldCenterPoint {
            constructor(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.distances = [];
                this.angles = [];
            }

            calculateDistances(points) {
                this.distances = points.map((point, index) => {
                    const distance = Math.abs(Math.sqrt(
                        (point.x - this.x) ** 2 +
                        (point.y - this.y) ** 2 +
                        (point.z - this.z) ** 2
                    ));
                    return { index, distance };
                });
            }

            calculateAngles(points) {
                this.angles = points.map((point, index) => {
                    if (index === 0) {
                        return { index, angle: 0 };
                    } else {
                        const prevPoint = points[index - 1];
                        const dx1 = prevPoint.x - this.x;
                        const dy1 = prevPoint.y - this.y;
                        const dz1 = prevPoint.z - this.z;
                        const dx2 = point.x - this.x;
                        const dy2 = point.y - this.y;
                        const dz2 = point.z - this.z;

                        const dotProduct = dx1 * dx2 + dy1 * dy2 + dz1 * dz2;
                        const magnitude1 = Math.sqrt(dx1 * dx1 + dy1 * dy1 + dz1 * dz1);
                        const magnitude2 = Math.sqrt(dx2 * dx2 + dy2 * dy2 + dz2 * dz2);

                        const angle = Math.acos(dotProduct / (magnitude1 * magnitude2)) * (180 / Math.PI);
                        return { index, angle };
                    }
                });
            }
        }

        class CombinedPoints {
            constructor(points) {
                this.points = points;
                this.distances = [];
            }

            calculateDistances() {
                this.distances = this.points.map((point, index) => {
                    if (index < this.points.length - 1) {
                        const nextPoint = this.points[index + 1];
                        const distance = Math.abs(Math.sqrt(
                            (nextPoint.x - point.x) ** 2 +
                            (nextPoint.y - point.y) ** 2 +
                            (nextPoint.z - point.z) ** 2
                        ));
                        return { index, distance };
                    } else {
                        return { index, distance: 0 };
                    }
                });
            }
        }

        drawingCanvas.addEventListener('mousedown', event => {
            if (!currentLine.length) {
                isDrawing = true;
                const startPoint = new Point(event.offsetX - centerX, event.offsetY - centerY, 0);
                points.push(startPoint);
                currentLine.push(startPoint);
                drawPoint(startPoint);
                lastPoint = startPoint;
            } else {
                const clickedPoint = getClickedPoint(event.offsetX, event.offsetY);
                if (clickedPoint) {
                    draggedPoint = clickedPoint;
                } else {
                    const clickedMirrorPoint = getClickedMirrorPoint(event.offsetX, event.offsetY);
                    if (clickedMirrorPoint) {
                        draggedMirrorPoint = clickedMirrorPoint;
                    } else if (centerPoint && isPointNear(event.offsetX, event.offsetY, centerPoint)) {
                        draggedCenterPoint = centerPoint;
                    } else {
                        const newPointOnLine = getNewPointOnLine(event.offsetX, event.offsetY);
                        if (newPointOnLine) {
                            points.splice(newPointOnLine.index, 0, newPointOnLine.point);
                            const startPoint = points[0];
                            const endPoint = points[points.length - 1];
                            mirrorPoints.splice(newPointOnLine.index, 0, getMirrorPoint(newPointOnLine.point, startPoint, endPoint));
                            redrawCanvas();
                        }
                    }
                }
            }
        });

        drawingCanvas.addEventListener('mousemove', event => {
            if (isDrawing) {
                const x = event.offsetX - centerX;
                const y = event.offsetY - centerY;
                const endPoint = new Point(x, y, 0);
                if (lastPoint && calculateDistance(lastPoint, endPoint) >= 50) {
                    points.push(endPoint);
                    drawPoint(endPoint);
                    drawLine(lastPoint, endPoint);
                    lastPoint = endPoint;
                    updateLineLength();
                }
            } else if (draggedPoint) {
                draggedPoint.x = event.offsetX - centerX;
                draggedPoint.y = event.offsetY - centerX;
                if (points.indexOf(draggedPoint) === 0) {
                    mirrorPoints[0].x = draggedPoint.x;
                    mirrorPoints[0].y = draggedPoint.y;
                } else if (points.indexOf(draggedPoint) === points.length - 1) {
                    mirrorPoints[mirrorPoints.length - 1].x = draggedPoint.x;
                    mirrorPoints[mirrorPoints.length - 1].y = draggedPoint.y;
                }
                redrawCanvas();
                updateLineLength();
            } else if (draggedMirrorPoint) {
                draggedMirrorPoint.x = event.offsetX - centerX;
                draggedMirrorPoint.y = event.offsetY - centerX;
                if (mirrorPoints.indexOf(draggedMirrorPoint) === 0) {
                    points[0].x = draggedMirrorPoint.x;
                    points[0].y = draggedMirrorPoint.y;
                } else if (mirrorPoints.indexOf(draggedMirrorPoint) === mirrorPoints.length - 1) {
                    points[points.length - 1].x = draggedMirrorPoint.x;
                    points[points.length - 1].y = draggedMirrorPoint.y;
                }
                redrawCanvas();
                updateLineLength();
            } else if (draggedCenterPoint) {
                draggedCenterPoint.x = event.offsetX - centerX;
                draggedCenterPoint.y = event.offsetY - centerY;
                redrawCanvas();
            }
        });

        drawingCanvas.addEventListener('mouseup', () => {
            if (isDrawing) {
                isDrawing = false;
                if (points.length > 1) {
                    const startPoint = points[0];
                    const endPoint = points[points.length - 1];
                    createMirrorSymmetry(startPoint, endPoint);
                    createCenterPoint();
                }
                lastPoint = null;
                surfaceDisplay = true;
            }
            draggedPoint = null;
            draggedMirrorPoint = null;
            draggedCenterPoint = null;
            redrawCanvas();
        });

        document.getElementById('rotateXPositiveButton').addEventListener('click', () => rotatePointsX(10));
        document.getElementById('rotateXNegativeButton').addEventListener('click', () => rotatePointsX(-10));
        document.getElementById('rotateYPositiveButton').addEventListener('click', () => rotatePointsY(10));
        document.getElementById('rotateYNegativeButton').addEventListener('click', () => rotatePointsY(-10));

        document.getElementById('resetButton').addEventListener('click', () => {
            surfaceDisplay = false;
            points = [];
            currentLine = [];
            angleX = 0;
            angleY = 0;
            mirrorPoints = [];
            centerPoint = null;
            drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            unfoldContext.clearRect(0, 0, unfoldCanvas.width, unfoldCanvas.height);
            document.getElementById('xRotationAngle').innerText = `X回転角: 0度`;
            document.getElementById('yRotationAngle').innerText = `Y回転角: 0度`;
            document.getElementById('lineLength').innerText = `線の長さ: 0px`;
        });

        document.getElementById('mirrorSymmetryResetButton').addEventListener('click', () => {
            if (points.length > 1) {
                const startPoint = points[0];
                const endPoint = points[points.length - 1];
                createMirrorSymmetry(startPoint, endPoint);
                createCenterPoint();
            }
        });

        document.getElementById('unfoldButton').addEventListener('click', () => {
            lineBreak = false;
            unfoldContext.clearRect(0, 0, unfoldCanvas.width, unfoldCanvas.height);
            combinedPoints = [...JSON.parse(JSON.stringify(points)), ...JSON.parse(JSON.stringify(mirrorPoints.reverse()))];
            combinedPoints = removeDuplicates(combinedPoints);
            combinedPointsClass = new CombinedPoints(combinedPoints);
            combinedPointsClass.calculateDistances();
            unfoldCenterPoint = new Point(centerPoint.x, centerPoint.y, centerPoint.z);
            unfoldCenterPointClass = new UnfoldCenterPoint(centerPoint.x, centerPoint.y, centerPoint.z);
            unfoldCenterPointClass.calculateDistances(combinedPoints);
            unfoldCenterPointClass.calculateAngles(combinedPoints);

            // Draw points and lines
            drawUnfoldedPointsAndLines(combinedPoints, 'black');

            // Draw center point
            if (unfoldCenterPoint) {
                drawUnfoldedPoint(unfoldCenterPoint, 'blue', 0, 0);
            }

            // Draw lines connecting to center point
            combinedPoints.forEach(point => {
                drawUnfoldedLine(point, unfoldCenterPoint, 'gray', 0, 0);
            });

            // Draw triangles
            combinedPoints.forEach(point => {
                if(combinedPoints.indexOf(point) < combinedPoints.length-1) {
                    fillUnfoldedTriangle(unfoldCenterPoint, point, combinedPoints[combinedPoints.indexOf(point)+1], 'rgba(211, 211, 211, 0.5)');
                }
                else {
                    if(!lineBreak) {
                      fillUnfoldedTriangle(unfoldCenterPoint, point, combinedPoints[0], 'rgba(211, 211, 211, 0.5)');
                    }
                }
            });

            // Highlight points exceeding tolerance angle
            highlightPointsExceedingTolerance();
        });

        // 重複を取り除く関数
        function removeDuplicates(array) {
            let uniqueArray = [];
            let uniqueSet = new Set();

            for (let point of array) {
                let key = JSON.stringify(point);
                if (!uniqueSet.has(key)) {
                    uniqueSet.add(key);
                    uniqueArray.push(point);
                }
            }

            return uniqueArray;
        }

        document.getElementById('unfoldRotateXPositiveButton').addEventListener('click', () => rotateUnfoldPointsX(10));
        document.getElementById('unfoldRotateXNegativeButton').addEventListener('click', () => rotateUnfoldPointsX(-10));
        document.getElementById('unfoldRotateYPositiveButton').addEventListener('click', () => rotateUnfoldPointsY(10));
        document.getElementById('unfoldRotateYNegativeButton').addEventListener('click', () => rotateUnfoldPointsY(-10));

        unfoldCanvas.addEventListener('mousedown', event => {
            const clickedPoint = getClickedUnfoldPoint(event.offsetX, event.offsetY);
            if (clickedPoint) {
                lineBreak = true;
                const clickedIndex = combinedPoints.indexOf(clickedPoint);
                combinedPoints = [
                    ...combinedPoints.slice(clickedIndex),
                    ...combinedPoints.slice(0, clickedIndex)
                ];
                combinedPoints.push(new Point(combinedPoints[0].x, combinedPoints[0].y, combinedPoints[0].z));
                unfoldCenterPointClass.distances.length = 0;
                unfoldCenterPointClass.calculateDistances(combinedPoints);
                unfoldCenterPointClass.calculateAngles(combinedPoints);
                combinedPointsClass = new CombinedPoints(combinedPoints);
                combinedPointsClass.calculateDistances();

                // Move unfoldCenterPoint to (0, 0, 0)
                unfoldCenterPoint.x = 0;
                unfoldCenterPoint.y = 0;
                unfoldCenterPoint.z = 0;

                // Move combinedPoints[0] to the negative Y direction
                combinedPoints[0].x = unfoldCenterPoint.x + unfoldCenterPointClass.distances[0].distance;
                combinedPoints[0].y = unfoldCenterPoint.y;
                combinedPoints[0].z = unfoldCenterPoint.z;

                let angle = 0;
                // [change here]
                for (let i = 1; i < combinedPoints.length; i++) {
                    const prevPoint = combinedPoints[i - 1];
                    const distance = unfoldCenterPointClass.distances[i].distance;
                    angle += unfoldCenterPointClass.angles[i].angle * (Math.PI / 180); // Convert to radians

                    combinedPoints[i].x = unfoldCenterPoint.x + distance * Math.cos(angle);
                    combinedPoints[i].y = unfoldCenterPoint.y + distance * Math.sin(angle);
                    combinedPoints[i].z = 0; // unfolded diagram is in 2D plane
                }

                redrawUnfoldCanvas();
            }
        });

        function rotatePointsX(angleIncrement) {
            angleX = (angleX + angleIncrement) % 360;
            const angleXInRadians = angleIncrement * Math.PI / 180;
            points = points.map(point => {
                const y = point.y * Math.cos(angleXInRadians) - point.z * Math.sin(angleXInRadians);
                const z = point.y * Math.sin(angleXInRadians) + point.z * Math.cos(angleXInRadians);
                return new Point(point.x, y, z);
            });
            mirrorPoints = mirrorPoints.map(point => {
                const y = point.y * Math.cos(angleXInRadians) - point.z * Math.sin(angleXInRadians);
                const z = point.y * Math.sin(angleXInRadians) + point.z * Math.cos(angleXInRadians);
                return new Point(point.x, y, z);
            });
            if (centerPoint) {
                const y = centerPoint.y * Math.cos(angleXInRadians) - centerPoint.z * Math.sin(angleXInRadians);
               const z = centerPoint.y * Math.sin(angleXInRadians) + centerPoint.z * Math.cos(angleXInRadians);
                centerPoint = new Point(centerPoint.x, y, z);
            }
            redrawCanvas();
            document.getElementById('xRotationAngle').innerText = `X回転角: ${angleX}度`;
            updateLineLength();
        }

        function rotatePointsY(angleIncrement) {
            angleY = (angleY + angleIncrement) % 360;
            const angleYInRadians = angleIncrement * Math.PI / 180;
            points = points.map(point => {
                const x = point.x * Math.cos(angleYInRadians) - point.z * Math.sin(angleYInRadians);
                const z = point.x * Math.sin(angleYInRadians) + point.z * Math.cos(angleYInRadians);
                return new Point(x, point.y, z);
            });
            mirrorPoints = mirrorPoints.map(point => {
                const x = point.x * Math.cos(angleYInRadians) - point.z * Math.sin(angleYInRadians);
                const z = point.x * Math.sin(angleYInRadians) + point.z * Math.cos(angleYInRadians);
                return new Point(x, point.y, z);
            });
            if (centerPoint) {
                               const x = centerPoint.x * Math.cos(angleYInRadians) - centerPoint.z * Math.sin(angleYInRadians);
                const z = centerPoint.x * Math.sin(angleYInRadians) + centerPoint.z * Math.cos(angleYInRadians);
                centerPoint = new Point(x, centerPoint.y, z);
            }
            redrawCanvas();
            document.getElementById('yRotationAngle').innerText = `Y回転角: ${angleY}度`;
            updateLineLength();
        }

        function rotateUnfoldPointsX(angleIncrement) {
            unfoldAngleX = (unfoldAngleX + angleIncrement) % 360;
            const angleXInRadians = angleIncrement * Math.PI / 180;
            combinedPoints = combinedPoints.map(point => {
                const y = point.y * Math.cos(angleXInRadians) - point.z * Math.sin(angleXInRadians);
                const z = point.y * Math.sin(angleXInRadians) + point.z * Math.cos(angleXInRadians);
                return new Point(point.x, y, z);
            });
            if (unfoldCenterPoint) {
                const y = unfoldCenterPoint.y * Math.cos(angleXInRadians) - unfoldCenterPoint.z * Math.sin(angleXInRadians);
                const z = unfoldCenterPoint.y * Math.sin(angleXInRadians) + unfoldCenterPoint.z * Math.cos(angleXInRadians);
                unfoldCenterPoint = new Point(unfoldCenterPoint.x, y, z);
            }
            redrawUnfoldCanvas();
            document.getElementById('unfoldXRotationAngle').innerText = `X回転角: ${unfoldAngleX}度`;
        }

        function rotateUnfoldPointsY(angleIncrement) {
            unfoldAngleY = (unfoldAngleY + angleIncrement) % 360;
            const angleYInRadians = angleIncrement * Math.PI / 180;
            combinedPoints = combinedPoints.map(point => {
                const x = point.x * Math.cos(angleYInRadians) - point.z * Math.sin(angleYInRadians);
                const z = point.x * Math.sin(angleYInRadians) + point.z * Math.cos(angleYInRadians);
                return new Point(x, point.y, z);
            });
            if (unfoldCenterPoint) {
                const x = unfoldCenterPoint.x * Math.cos(angleYInRadians) - unfoldCenterPoint.z * Math.sin(angleYInRadians);
                const z = unfoldCenterPoint.x * Math.sin(angleYInRadians) + unfoldCenterPoint.z * Math.cos(angleYInRadians);
                unfoldCenterPoint = new Point(x, unfoldCenterPoint.y, z);
            }
            redrawUnfoldCanvas();
            document.getElementById('unfoldYRotationAngle').innerText = `Y回転角: ${unfoldAngleY}度`;
        }

        function getClickedUnfoldPoint(x, y) {
            for (const point of combinedPoints) {
                const dx = x - (point.x + unfoldCenterX);
                const dy = y - (point.y + unfoldCenterY);
                if (Math.sqrt(dx * dx + dy * dy) < 5) return point;
            }
            return null;
        }

        function redrawUnfoldCanvas() {
            unfoldContext.clearRect(0, 0, unfoldCanvas.width, unfoldCanvas.height);

            // Draw points and lines
            drawUnfoldedPointsAndLines(combinedPoints, 'black');

            // Draw center point
            if (unfoldCenterPoint) {
               drawUnfoldedPoint(unfoldCenterPoint, 'blue', 0, 0);
            }

            // Draw lines connecting to center point
            combinedPoints.forEach(point => {
                if(combinedPoints.indexOf(point) === 0 || combinedPoints.indexOf(point) === combinedPoints.length - 1) {
                  if(!lineBreak) {          
                    drawUnfoldedLine(point, unfoldCenterPoint, 'black', 0, 0);  
                  }
                  else {
                    drawUnfoldedLine(point, unfoldCenterPoint, 'red', 0, 0);  
                  }      
                }
                else {
                  drawUnfoldedLine(point, unfoldCenterPoint, 'black', 0, 0);
                }
            });
        }

        function drawPoint(point, color = 'black') {
            const size = Math.max(1, (10 - point.z / 20) * 0.5);
            drawingContext.beginPath();
            drawingContext.arc(point.x + centerX, point.y + centerY, size, 0, 2 * Math.PI);
            drawingContext.fillStyle = color;
            drawingContext.globalAlpha = 0.5;
            drawingContext.fill();
            drawingContext.globalAlpha = 1.0;
        }

        function drawLine(start, end, color = 'black') {
            drawingContext.beginPath();
            drawingContext.moveTo(start.x + centerX, start.y + centerY);
            drawingContext.lineTo(end.x + centerX, end.y + centerY);
            drawingContext.strokeStyle = color;
            drawingContext.stroke();
        }

        function getClickedPoint(x, y) {
            for (const point of points) {
                const dx = x - (point.x + centerX);
                const dy = y - (point.y + centerY);
                if (Math.sqrt(dx * dx + dy * dy) < 5) return point;
            }
            return null;
        }

        function getClickedMirrorPoint(x, y) {
            for (const point of mirrorPoints) {
                const dx = x - (point.x + centerX);
                const dy = y - (point.y + centerY);
                if (Math.sqrt(dx * dx + dy * dy) < 5) return point;
            }
            return null;
        }

        function isPointNear(x, y, point) {
            const dx = x - (point.x + centerX);
            const dy = y - (point.y + centerY);
            return Math.sqrt(dx * dx + dy * dy) < 5;
        }

        function getNewPointOnLine(x, y) {
            const clickedX = x - centerX;
            const clickedY = y - centerY;
            for (let i = 0; i < points.length - 1; i++) {
                const start = points[i];
                const end = points[i + 1];
                const distanceToLine = calculatePointToLineDistance(clickedX, clickedY, start, end);
                if (distanceToLine < 5) {
                    const t = ((clickedX - start.x) * (end.x - start.x) + (clickedY - start.y) * (end.y - start.y)) / ((end.x - start.x) ** 2 + (end.y - start.y) ** 2);
                    const newX = start.x + t * (end.x - start.x);
                    const newY = start.y + t * (end.y - start.y);
                    return { point: new Point(newX, newY, 0), index: i + 1 };
                }
            }
            return null;
        }

        function calculatePointToLineDistance(px, py, start, end) {
            const A = px - start.x;
            const B = py - start.y;
            const C = end.x - start.x;
            const D = end.y - start.y;
            const dot = A * C + B * D;
            const lengthSquared = C * C + D * D;
            const param = dot / lengthSquared;
            let xx, yy;
            if (param < 0 || (start.x === end.x && start.y === end.y)) {
                xx = start.x;
                yy = start.y;
            } else if (param > 1) {
                xx = end.x;
                yy = end.y;
            } else {
                xx = start.x + param * C;
                yy = start.y + param * D;
            }
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function calculateDistance(point1, point2) {
            return Math.sqrt((point2.x - point1.x) ** 2 + (point2.y - point1.y) ** 2 + (point2.z - point1.z) ** 2);
        }

        function redrawCanvas() {
            drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            for (let i = 0; i < points.length; i++) {
                drawPoint(points[i]);
                if (i > 0) drawLine(points[i - 1], points[i]);
            }
            for (let i = 0; i < mirrorPoints.length; i++) {
                drawPoint(mirrorPoints[i], 'red');
                if (i > 0) drawLine(mirrorPoints[i - 1], mirrorPoints[i], 'red');
            }
            if (surfaceDisplay && points.length > 1) {
                drawSurface();
            }
        }

        function updateLineLength() {
            if (points.length > 1) {
                const start = points[0];
                const end = points[points.length - 1];
                const length = calculateDistance(start, end);
                document.getElementById('lineLength').innerText = `線の長さ: ${length.toFixed(2)}px`;
            } else {
                document.getElementById('lineLength').innerText = `線の長さ: 0px`;
            }
        }

        function createMirrorSymmetry(startPoint, endPoint) {
            mirrorPoints = points.map(point => getMirrorPoint(point, startPoint, endPoint));
            redrawCanvas();
        }

        function getMirrorPoint(point, startPoint, endPoint) {
            const dx = endPoint.x - startPoint.x;
            const dy = endPoint.y - startPoint.y;
            const a = (dx * dx - dy * dy) / (dx * dx + dy * dy);
            const b = 2 * dx * dy / (dx * dx + dy * dy);
            const x = a * (point.x - startPoint.x) + b * (point.y - startPoint.y) + startPoint.x;
            const y = b * (point.x - startPoint.x) - a * (point.y - startPoint.y) + startPoint.y;
            return new Point(x, y, point.z);
        }

        function createCenterPoint() {
            const startPoint = points[0];
            const endPoint = points[points.length - 1];
            centerPoint = new Point((startPoint.x + endPoint.x) / 2, (startPoint.y + endPoint.y) / 2, 0);
            redrawCanvas();
        }

        function drawSurface() {
            if (centerPoint) {
                drawPoint(centerPoint, 'blue');
                for (let i = 0; i < points.length; i++) {
                    drawLine(centerPoint, points[i], 'gray');
                    drawLine(centerPoint, mirrorPoints[i], 'gray');
                    if (i < points.length - 1) {
                        fillTriangle(centerPoint, points[i], points[i + 1], 'rgba(211, 211, 211, 0.5)');
                        fillTriangle(centerPoint, mirrorPoints[i], mirrorPoints[i + 1], 'rgba(211, 211, 211, 0.5)');
                    }
                }
            }
        }

        function fillTriangle(p1, p2, p3, color) {
            drawingContext.beginPath();
            drawingContext.moveTo(p1.x + centerX, p1.y + centerY);
            drawingContext.lineTo(p2.x + centerX, p2.y + centerY);
            drawingContext.lineTo(p3.x + centerX, p3.y + centerY);
            drawingContext.closePath();
            drawingContext.fillStyle = color;
            drawingContext.fill();
        }

        function drawUnfoldedPointsAndLines(points, color) {
            points.forEach((point, index) => {
                drawUnfoldedPoint(point, color, 0, 0);
                if (index > 0) {
                    drawUnfoldedLine(points[index - 1], point, color, 0, 0);
                } else {
                    if(!lineBreak) {
                        drawUnfoldedLine(points[points.length - 1], point, color, 0, 0);
                    }
                }
            });
        }

        function drawUnfoldedPoint(point, color, offsetX, offsetY) {
            const size = Math.max(1, (10 - point.z / 20) * 0.5);
            unfoldContext.beginPath();
            unfoldContext.arc(point.x + unfoldCenterX + offsetX, point.y + unfoldCenterY + offsetY, size, 0, 2 * Math.PI);
            unfoldContext.fillStyle = color;
            unfoldContext.globalAlpha = 0.5;
            unfoldContext.fill();
            unfoldContext.globalAlpha = 1.0;
        }

        function drawUnfoldedLine(start, end, color, offsetX, offsetY, lineWidth = 1) {
            unfoldContext.beginPath();
            unfoldContext.moveTo(start.x + unfoldCenterX + offsetX, start.y + unfoldCenterY + offsetY);
            unfoldContext.lineTo(end.x + unfoldCenterX + offsetX, end.y + unfoldCenterY + offsetY);
            unfoldContext.strokeStyle = color;
            unfoldContext.lineWidth = lineWidth;
            unfoldContext.stroke();
        }

        function fillUnfoldedTriangle(p1, p2, p3, color) {
            unfoldContext.beginPath();
            unfoldContext.moveTo(p1.x + unfoldCenterX, p1.y + unfoldCenterY);
            unfoldContext.lineTo(p2.x + unfoldCenterX, p2.y + unfoldCenterY);
            unfoldContext.lineTo(p3.x + unfoldCenterX, p3.y + unfoldCenterY);
            unfoldContext.closePath();
            unfoldContext.fillStyle = color;
            unfoldContext.fill();
        }

        function highlightPointsExceedingTolerance() {
            const toleranceAngle = parseFloat(document.getElementById('toleranceAngle').value);
            combinedPoints.forEach(point => {
                const angle = calculateAngleWithXPlane(point);
                if (angle > toleranceAngle) {
                    drawUnfoldedPoint(point, 'red', 0, 0);
                }
            });
        }

        function calculateAngleWithXPlane(point) {
            if (!unfoldCenterPoint) return 0;
            const dx = point.x - unfoldCenterPoint.x;
            const dy = point.y - unfoldCenterPoint.y;
            const dz = point.z - unfoldCenterPoint.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            return Math.acos(dx / distance) * (180 / Math.PI);
        }
    </script>
</body>
</html>
