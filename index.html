<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device=1.0">
    <title>Canvas Drawing and Rotation</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <style>
        canvas {
            border: 1px solid black;
            position: relative;
        }
        .button-img {
            width: 64px;
            height: 64px;
        }
        .active-mode {
            background-color: green !important;
        }
        .inactive-mode {
            background-color: gray !important;
        }
        #instructionText {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: white;
            padding: 5px;
            border: 1px solid black;
            display: none;
        }
        #unfoldingText {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: blue;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="row">
            <div class="col-md-2">
                <button id="drawButton" class="btn btn-success mb-2 inactive-mode">描く</button>
                <div class="form-check">
                    <input type="checkbox" class="form-check-input" id="closePathCheckbox">
                    <label class="form-check-label" for="closePathCheckbox">パスを閉じる</label>
                </div>
                <button id="drawInnerLineButton" class="btn btn-success mb-2 inactive-mode">つなぐ</button>
                <div class="form-check">
                    <input type="checkbox" class="form-check-input" id="deleteLineCheckBox">
                    <label class="form-check-label" for="deleteLineCheckBox">線を消す</label>
                </div>
                <div class="form-check">
                    <input type="checkbox" class="form-check-input" id="deletePointCheckBox">
                    <label class="form-check-label" for="deletePointCheckBox">点を消す</label>
                </div>
                <div class="form-check">
                    <input type="checkbox" class="form-check-input" id="showFacesCheckbox">
                    <label class="form-check-label" for="showFacesCheckbox">面を表示</label>
                </div>
                <button id="arcButton" class="btn btn-success mb-2 inactive-mode">Arc</button>
                <button id="cutButton" class="btn btn-success mb-2 inactive-mode">カット</button>
                <div class="form-check">
                    <input type="checkbox" class="form-check-input" id="unfoldCheckbox" disabled>
                    <label class="form-check-label" for="unfoldCheckbox">展開</label>
                </div>
            </div>
            <div class="col-md-9 position-relative">
                <canvas id="drawingCanvas" width="500" height="500"></canvas>
                <div id="instructionText">２つ点をえらんでください</div>
                <div id="unfoldingText">展開処理中・・・</div>
            </div>
            <div class="col-md-1 d-flex flex-column align-items-start">
                <button id="rotateXPositiveButton" class="btn-primary mb-2">↓</button>
                <button id="rotateXNegativeButton" class="btn-primary mb-2">↑</button>
                <div id="xRotationAngle" class="mb-2">X: 0度</div>
                <button id="rotateYNegativeButton" class="btn-primary mb-2">←</button>
                <button id="rotateYPositiveButton" class="btn-primary mb-2">→</button>
                <div id="yRotationAngle" class="mb-2">Y: 0度</div>
                <button id="resetButton" class="btn-danger mb-2">線を書き直す</button>
            </div>
        </div>
    </div>

    <script>
        const drawingCanvas = document.getElementById('drawingCanvas');
        const drawingContext = drawingCanvas.getContext('2d');
        const centerX = drawingCanvas.width / 2;
        const centerY = drawingCanvas.height / 2;

        let isDrawing = false;
        let outlinePoints = [];
        let angleX = 0;
        let angleY = 0;
        let currentLine = [];
        let draggedPoint = null;
        let lastPoint = null;
        let lastDrawTime = 0;
        let majorMode = null;
        let insertAtStart = false;
        let pathClosed = false;
        let selectedPoints = [];
        let unfoldPoints = [];
        let pointCounter = 0;
        let unFolded = false;

        class Point {
            constructor(x, y, z, isArc = false, selected = false, name = null, connectedPoints = null, isCutBetween = null) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.isArc = isArc;
                this.selected = selected;
                if(name !== null){
                  this.name = name;
                }
                else {
                  this.name = pointCounter++;
                }
                if(connectedPoints){
                  this.connectedPoints = [...connectedPoints];
                }
                else {
                  this.connectedPoints = [];
                }
                if(isCutBetween){
                  this.isCutBetween = [...isCutBetween];
                }
                else {
                  this.isCutBetween = [];
                }
            }

            addConnectedPoint(point) {
                if (!this.connectedPoints.includes(point.name)) {
                    this.connectedPoints.push(point.name);
                }
            }

            removeConnectedPoint(point) {
                this.connectedPoints = this.connectedPoints.filter(name => name !== point.name);
            }

            isConnected(point){
                if(this.connectedPoints.includes(point.name)){
                    return true;
                }
                return false;
            }

            updatePosition(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            addCutBetween(point) {
                if (!this.isCutBetween.includes(point.name)) {
                    this.isCutBetween.push(point.name);
                }
            }

            isCutWith(point) {
                if(point) {
                  return this.isCutBetween.includes(point.name);
                }
                return false;
            }

            clone() {
                return new Point(this.x, this.y, this.z, this.isArc, this.selected, this.name, this.connectedPoints, this.isCutBetween);
            }
        }

        function getPointByName(name) {
            for (const point of outlinePoints) {
                if (point.name === name) {
                    return point;
                }
            }
            return null;
        }

        setMajorMode('draw');

        function setMajorMode(mode) {
            majorMode = mode;
            document.querySelectorAll('.btn').forEach(button => {
                button.classList.remove('active-mode');
                button.classList.add('inactive-mode');
            });
            if (mode === 'draw') {
                document.getElementById('drawButton').classList.add('active-mode');
                document.getElementById('drawButton').classList.remove('inactive-mode');
                document.getElementById('instructionText').style.display = 'none';
                document.getElementById('unfoldCheckbox').checked = false;
                document.getElementById('unfoldCheckbox').disabled = true;
                redrawCanvas();
            } else if (mode === 'arc') {
                document.getElementById('arcButton').classList.add('active-mode');
                document.getElementById('arcButton').classList.remove('inactive-mode');
                document.getElementById('instructionText').style.display = 'block';
                document.getElementById('unfoldCheckbox').checked = false;
                document.getElementById('unfoldCheckbox').disabled = true;
                redrawCanvas();
            } else if (mode === 'drawInnerLine') {
                document.getElementById('drawInnerLineButton').classList.add('active-mode');
                document.getElementById('drawInnerLineButton').classList.remove('inactive-mode');
                if (!document.getElementById('deleteLineCheckBox').checked) {
                    document.getElementById('instructionText').style.display = 'block';
                    document.getElementById('instructionText').innerText = '２つ点をえらんでください';
                    document.getElementById('instructionText').style.color = 'black';
                } else {
                    document.getElementById('instructionText').style.display = 'none';
                }
                document.getElementById('unfoldCheckbox').checked = false;
                document.getElementById('unfoldCheckbox').disabled = true;
                redrawCanvas();
            } else if (mode === 'cut') {
                document.getElementById('cutButton').classList.add('active-mode');
                document.getElementById('cutButton').classList.remove('inactive-mode');
                document.getElementById('instructionText').style.display = 'none';
                document.getElementById('unfoldCheckbox').disabled = false;
                redrawCanvas();
            } else {
                document.getElementById('instructionText').style.display = 'none';
                document.getElementById('unfoldCheckbox').checked = false;
                document.getElementById('unfoldCheckbox').disabled = true;
                redrawCanvas();
            }
            outlinePoints.forEach(point => point.selected = false);
        }

        document.getElementById('drawButton').addEventListener('click', () => setMajorMode('draw'));
        document.getElementById('arcButton').addEventListener('click', () => setMajorMode('arc'));
        document.getElementById('drawInnerLineButton').addEventListener('click', () => setMajorMode('drawInnerLine'));
        document.getElementById('cutButton').addEventListener('click', () => setMajorMode('cut'));

        document.getElementById('closePathCheckbox').addEventListener('change', () => {
            pathClosed = document.getElementById('closePathCheckbox').checked;
            redrawCanvas();
        });
        document.getElementById('showFacesCheckbox').addEventListener('change', () => {
            redrawCanvas();
        });
        document.getElementById('unfoldCheckbox').addEventListener('change', () => {
            if(document.getElementById('unfoldCheckbox').checked){
                unfoldPoints = outlinePoints.map(point => new Point(point.x, point.y, point.z, point.isArc, point.selected, point.name, point.connectedPoints, point.isCutBetween));

console.log("outlinePoints = ", outlinePoints);
console.log("unfoldPoints = ", unfoldPoints);
                unfoldPoints = unfoldPoints.flatMap(point => {
                    if (point.isCutBetween.length > 0) {
                        const newPoints = [];
                        point.isCutBetween.forEach(cutPointName => {
                            const cutPoint = getPointByName(cutPointName);
                            const newPoint = new Point(point.x, point.y, point.z, point.isArc, point.selected, null, point.connectedPoints, point.isCutBetween);
                            newPoint.connectedPoints = newPoint.connectedPoints.filter(name => name === cutPointName);
                            newPoints.push(newPoint);
                            point.connectedPoints = point.connectedPoints.filter(name => name !== cutPointName);
                        });
                        return [point, ...newPoints];
                    }
                    return [point];
                });
                redrawCanvas();
            } else {
                unFolded = false;
                redrawCanvas();
            }
        });

        drawingCanvas.addEventListener('mousedown', event => {
            if (majorMode === 'draw') {
                if (!currentLine.length) {
                    isDrawing = true;
                    const startPoint = new Point(event.offsetX - centerX, event.offsetY - centerY, 0);
                    outlinePoints.push(startPoint);
                    currentLine.push(startPoint);
                    drawPoint(startPoint);
                    lastPoint = startPoint;
                    lastDrawTime = Date.now();
                } else {
                    const clickedPoint = getClickedPoint(event.offsetX, event.offsetY);
                    if (clickedPoint) {
                        draggedPoint = clickedPoint;
                    } else {
                        const newPointOnLine = getNewPointOnLine(event.offsetX, event.offsetY);
                        if (newPointOnLine) {
                            const prevPoint = outlinePoints[newPointOnLine.index - 1];
                            const nextPoint = outlinePoints[newPointOnLine.index];
                            prevPoint.removeConnectedPoint(nextPoint);
                            nextPoint.removeConnectedPoint(prevPoint);
                            outlinePoints.splice(newPointOnLine.index, 0, newPointOnLine.point);
                            prevPoint.addConnectedPoint(newPointOnLine.point);
                            newPointOnLine.point.addConnectedPoint(prevPoint);
                            nextPoint.addConnectedPoint(newPointOnLine.point);
                            newPointOnLine.point.addConnectedPoint(nextPoint);
                            redrawCanvas();
                        } else {
                            if (!pathClosed) {
                                const newPoint = new Point(event.offsetX - centerX, event.offsetY - centerY, 0);
                                const closestEndPoint = getClosestEndPoint(newPoint);
                                if (closestEndPoint.index === 1) {
                                    outlinePoints.unshift(newPoint);
                                    insertAtStart = true;
                                } else {
                                    outlinePoints.splice(closestEndPoint.index, 0, newPoint);
                                    insertAtStart = false;
                                }
                                redrawCanvas();
                                isDrawing = true;
                                lastPoint = newPoint;
                            }
                        }
                    }
                }
            } else if (majorMode === 'arc') {
                const clickedPoint = getClickedPoint(event.offsetX, event.offsetY);
                if (clickedPoint) {
                    if (selectedPoints.length < 2) {
                        selectedPoints.push(clickedPoint);
                        clickedPoint.isArc = true;
                    } else {
                        selectedPoints.forEach(point => point.isArc = false);
                        selectedPoints = [clickedPoint];
                        clickedPoint.isArc = true;
                    }
                    redrawCanvas();
                }
            } else if (majorMode === 'drawInnerLine') {
                if (document.getElementById('deleteLineCheckBox').checked) {
                    const clickedLine = getClickedInnerLine(event.offsetX, event.offsetY);
                    if (clickedLine) {
                        const [start, end] = clickedLine.line;
                        start.removeConnectedPoint(end);
                        end.removeConnectedPoint(start);
                        redrawCanvas();
                    }
                } else {
                    const clickedPoint = getClickedPoint(event.offsetX, event.offsetY);
                    if (clickedPoint) {
                        clickedPoint.selected = true;
                        selectedPoints.push(clickedPoint);
                        if (selectedPoints.length === 2) {
                            selectedPoints[0].addConnectedPoint(selectedPoints[1]);
                            selectedPoints[1].addConnectedPoint(selectedPoints[0]);
                            selectedPoints.forEach(point => point.selected = false);
                            selectedPoints = [];
                        }
                        redrawCanvas();
                    }
                }
            } else if (majorMode === 'cut') {
                const clickedLine = getClickedInnerLine(event.offsetX, event.offsetY);
                if (clickedLine) {
                    if (!document.getElementById('unfoldCheckbox').checked) {
                        const [start, end] = clickedLine.line;
                        start.addCutBetween(end);
                        end.addCutBetween(start);
                        redrawCanvas();
                        //修正要望: if the line is already cut, undo cut.
                    } else {
                        const [start, end] = clickedLine.line;
console.log(" start = ", start);
console.log(" end = ", end);
                        const triangles = getTrianglesSharingEdge(start, end);

console.log(" triangles = ", triangles);

                        if (triangles.length > 0) {
                            rotateTrianglesToAlignNormals(triangles, start, end);
                            redrawCanvas();
                        }
                    }
                }
            }

            if (document.getElementById('deletePointCheckBox').checked) {
                const clickedPoint = getClickedPoint(event.offsetX, event.offsetY);
                if (clickedPoint) {
                    outlinePoints = outlinePoints.filter(point => point !== clickedPoint);
                    outlinePoints.forEach(point => point.removeConnectedPoint(clickedPoint));
                    redrawCanvas();
                }
            }
        });

        drawingCanvas.addEventListener('mousemove', event => {
            if (majorMode === 'draw') {
                if (isDrawing) {
                    const currentTime = Date.now();
                    if (currentTime - lastDrawTime >= 500) {
                        const x = event.offsetX - centerX;
                        const y = event.offsetY - centerY;
                        const endPoint = new Point(x, y, 0);
                        if (insertAtStart) {
                            outlinePoints.unshift(endPoint);
                        } else {
                            outlinePoints.push(endPoint);
                        }
                        drawPoint(endPoint);
                        drawLine(lastPoint, endPoint);
                        lastPoint.addConnectedPoint(endPoint);
                        endPoint.addConnectedPoint(lastPoint);
                        lastPoint = endPoint;
                        lastDrawTime = currentTime;
                    }
                } else if (draggedPoint) {
                    draggedPoint.updatePosition(event.offsetX - centerX, event.offsetY - centerY, draggedPoint.z);
                    redrawCanvas();
                }
            }
        });

        drawingCanvas.addEventListener('mouseup', () => {
            if (majorMode === 'draw') {
                if (isDrawing) {
                    isDrawing = false;
                    lastPoint = null;
                }
                draggedPoint = null;
                redrawCanvas();
            }
        });

        document.getElementById('rotateXPositiveButton').addEventListener('click', () => rotatePointsX(10));
        document.getElementById('rotateXNegativeButton').addEventListener('click', () => rotatePointsX(-10));
        document.getElementById('rotateYPositiveButton').addEventListener('click', () => rotatePointsY(10));
        document.getElementById('rotateYNegativeButton').addEventListener('click', () => rotatePointsY(-10));

        document.getElementById('resetButton').addEventListener('click', () => {
            pointCounter = 0;
            outlinePoints = [];
            currentLine = [];
            angleX = 0;
            angleY = 0;
            drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            document.getElementById('xRotationAngle').innerText = `X: 0度`;
            document.getElementById('yRotationAngle').innerText = `Y: 0度`;
            pathClosed = false;
            document.getElementById('instructionText').style.display = 'none';
            selectedPoints = [];
            document.getElementById('closePathCheckbox').checked = false;
            document.getElementById('showFacesCheckbox').checked = false;
            document.getElementById('deletePointCheckBox').checked = false;
            document.getElementById('unfoldCheckbox').checked = false;
            document.getElementById('unfoldCheckbox').disabled = true;
        });

        function rotatePointsX(angleIncrement) {
            angleX = (angleX + angleIncrement) % 360;
            const angleXInRadians = angleIncrement * Math.PI / 180;
            for (const point of outlinePoints) {
                const y = point.y * Math.cos(angleXInRadians) - point.z * Math.sin(angleXInRadians);
                const z = point.y * Math.sin(angleXInRadians) + point.z * Math.cos(angleXInRadians);
                point.updatePosition(point.x, y, z);
            }
            redrawCanvas();
            document.getElementById('xRotationAngle').innerText = `X: ${angleX}度`;
        }

        function rotatePointsY(angleIncrement) {
            angleY = (angleY + angleIncrement) % 360;
            const angleYInRadians = angleIncrement * Math.PI / 180;
            for (const point of outlinePoints) {
                const x = point.x * Math.cos(angleYInRadians) - point.z * Math.sin(angleYInRadians);
                const z = point.x * Math.sin(angleYInRadians) + point.z * Math.cos(angleYInRadians);
                point.updatePosition(x, point.y, z);
            }
            redrawCanvas();
            document.getElementById('yRotationAngle').innerText = `Y: ${angleY}度`;
        }

        function drawPoint(point, color = 'black') {
            const size = Math.max(1, (10 - point.z / 20) * 0.5);
            drawingContext.beginPath();
            drawingContext.arc(point.x + centerX, point.y + centerY, size, 0, 2 * Math.PI);
            if (majorMode === 'arc') {
                drawingContext.fillStyle = point.isArc ? 'blue' : color;
            } else if (point.selected) {
                drawingContext.fillStyle = 'red';
            } else {
                drawingContext.fillStyle = color;
            }
            drawingContext.globalAlpha = 0.5;
            drawingContext.fill();
            drawingContext.globalAlpha = 1.0;
        }

        function drawLine(start, end, color = 'black') {
            if(start.isConnected(end) && end.isConnected(start)){
                drawingContext.beginPath();
                drawingContext.moveTo(start.x + centerX, start.y + centerY);
                drawingContext.lineTo(end.x + centerX, end.y + centerY);
                if (majorMode === 'cut' && start.isCutWith(end) && end.isCutWith(start)) {
                    drawingContext.strokeStyle = 'blue';
                } else {
                    drawingContext.strokeStyle = color;
                }
                drawingContext.stroke();
            }
        }

        function getClickedPoint(x, y) {
            const pointsToCheck = document.getElementById('unfoldCheckbox').checked ? unfoldPoints : outlinePoints;
            for (const point of pointsToCheck) {
                const dx = x - (point.x + centerX);
                const dy = y - (point.y + centerY);
                if (Math.sqrt(dx * dx + dy * dy) < 10) return point;
            }
            return null;
        }

        function getClickedInnerLine(x, y) {
            const clickedX = x - centerX;
            const clickedY = y - centerY;
            const pointsToCheck = document.getElementById('unfoldCheckbox').checked ? unfoldPoints : outlinePoints;
            for (let i = 0; i < pointsToCheck.length; i++) {
                const start = pointsToCheck[i];
                for (let j = 0; j < start.connectedPoints.length; j++) {
                    const end = getPointByName(start.connectedPoints[j]);
                    const distanceToLine = calculatePointToLineDistance(clickedX, clickedY, start, end);
                    if (distanceToLine < 5) {
                        return { line: [start, end], index: i };
                    }
                }
            }
            return null;
        }

        function getNewPointOnLine(x, y) {
            const clickedX = x - centerX;
            const clickedY = y - centerY;
            const pointsToCheck = document.getElementById('unfoldCheckbox').checked ? unfoldPoints : outlinePoints;
            for (let i = 0; i < pointsToCheck.length; i++) {
                const start = pointsToCheck[i];
                for (let j = 0; j < start.connectedPoints.length; j++) {
                    const end = getPointByName(start.connectedPoints[j]);
                    const distanceToLine = calculatePointToLineDistance(clickedX, clickedY, start, end);
                    if (distanceToLine < 10) {
                        const t = ((clickedX - start.x) * (end.x - start.x) + (clickedY - start.y) * (end.y - start.y)) / (((end.x - start.x) ** 2 + (end.y - start.y) ** 2));
                        const newX = start.x + t * (end.x - start.x);
                        const newY = start.y + t * (end.y - start.y);
                        return { point: new Point(newX, newY, 0), index: i + 1 };
                    }
                }
            }
            return null;
        }

        function getClosestEndPoint(newPoint) {
            const startPoint = outlinePoints[0];
            const endPoint = outlinePoints[outlinePoints.length - 1];
            const distanceToStart = calculateDistance(newPoint, startPoint);
            const distanceToEnd = calculateDistance(newPoint, endPoint);
            if (distanceToStart < distanceToEnd) {
                return { point: startPoint, index: 1 };
            } else {
                return { point: endPoint, index: outlinePoints.length };
            }
        }

        function calculatePointToLineDistance(px, py, start, end) {
            const A = px - start.x;
            const B = py - start.y;
            const C = end.x - start.x;
            const D = end.y - start.y;
            const dot = A * C + B * D;
            const lengthSquared = C * C + D * D;
            const param = dot / lengthSquared;
            let xx, yy;
            if (param < 0 || (start.x === end.x && start.y === end.y)) {
                xx = start.x;
                yy = start.y;
            } else if (param > 1) {
                xx = end.x;
                yy = end.y;
            } else {
                xx = start.x + param * C;
                yy = start.y + param * D;
            }
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function calculateDistance(point1, point2) {
            return Math.sqrt((point2.x - point1.x) ** 2 + (point2.y - point1.y) ** 2 + (point2.z - point1.z) ** 2);
        }

        function redrawCanvas() {
            drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            const pointsToDraw = document.getElementById('unfoldCheckbox').checked ? unfoldPoints : outlinePoints;
            for (let i = 0; i < pointsToDraw.length; i++) {
                drawPoint(pointsToDraw[i]);
                for (let j = 0; j < pointsToDraw[i].connectedPoints.length; j++) {
                    const connectedPoint = getPointByName(pointsToDraw[i].connectedPoints[j]);
                    drawLine(pointsToDraw[i], connectedPoint);
                }
            }
            if (pathClosed && outlinePoints.length > 1) {
                drawLine(outlinePoints[outlinePoints.length - 1], outlinePoints[0]);
                outlinePoints[outlinePoints.length - 1].addConnectedPoint(outlinePoints[0]);
                outlinePoints[0].addConnectedPoint(outlinePoints[outlinePoints.length - 1]);
            }
            if (majorMode === 'arc') {
                let arcPoints = outlinePoints.filter(item => item.isArc);
                if (arcPoints.length === 2) {
                    drawLine(arcPoints[0], arcPoints[1], 'blue');
                }
            }

            if (document.getElementById('showFacesCheckbox').checked) {
                drawFaces();
            }

            if (majorMode === 'cut') {
                drawCutLines();
            }

            //if (document.getElementById('unfoldCheckbox').checked && majorMode === 'cut') {
            //    unfoldTriangles();
            //}
        }

        function closePath() {
            if (outlinePoints.length > 1) {
                const startPoint = outlinePoints[0];
                const endPoint = outlinePoints[outlinePoints.length - 1];
                if (calculateDistance(startPoint, endPoint) < 1) {
                    outlinePoints.pop();
                }
                redrawCanvas();
            }
        }

        function removeDuplicatePoints() {
            for (let i = 0; i < outlinePoints.length - 1; i++) {
                if (outlinePoints[i].x === outlinePoints[i + 1].x && outlinePoints[i].y === outlinePoints[i + 1].y && outlinePoints[i].z === outlinePoints[i + 1].z) {
                    outlinePoints.splice(i + 1, 1);
                    i--; // Adjust index after removal
                }
            }
            redrawCanvas();
        }

        function drawFaces() {
            const triangles = [];

            for (let i = 0; i < outlinePoints.length; i++) {
                for (let j = 0; j < outlinePoints.length; j++) {
                    for (let k = 0; k < outlinePoints.length; k++) {
                        const p1 = outlinePoints[i];
                        const p2 = outlinePoints[j];
                        const p3 = outlinePoints[k];

                        if (p1.isConnected(p2) && p2.isConnected(p3) && p3.isConnected(p1)) {
                            const area = calculateTriangleArea(p1, p2, p3);
                            triangles.push({ points: [p1, p2, p3], area });
                        }
                    }
                }
            }

            triangles.sort((a, b) => a.area - b.area);

            const drawnTriangles = [];

            triangles.forEach(triangle => {
                if (!isTriangleOverlapping(triangle, drawnTriangles)) {
                    drawTriangle(triangle.points[0], triangle.points[1], triangle.points[2]);
                    drawnTriangles.push(triangle);
                }
            });
        }

        function calculateTriangleArea(p1, p2, p3) {
            const a = calculateDistance(p1, p2);
            const b = calculateDistance(p2, p3);
            const c = calculateDistance(p3, p1);
            const s = (a + b + c) / 2;
            return Math.sqrt(s * (s - a) * (s - b) * (s - c));
        }

        function isTriangleOverlapping(triangle, drawnTriangles) {
            return drawnTriangles.some(drawnTriangle => {
                const [p1, p2, p3] = triangle.points;
                const [dp1, dp2, dp3] = drawnTriangle.points;
                return (p1.name === dp1.name && p2.name === dp2.name && p3.name === dp3.name) ||
                       (p1.name === dp1.name && p2.name === dp3.name && p3.name === dp2.name) ||
                       (p1.name === dp2.name && p2.name === dp1.name && p3.name === dp3.name) ||
                       (p1.name === dp2.name && p2.name === dp3.name && p3.name === dp1.name) ||
                       (p1.name === dp3.name && p2.name === dp1.name && p3.name === dp2.name) ||
                       (p1.name === dp3.name && p2.name === dp2.name && p3.name === dp1.name);
            });
        }

        function drawTriangle(p1, p2, p3) {
            drawingContext.beginPath();
            drawingContext.moveTo(p1.x + centerX, p1.y + centerY);
            drawingContext.lineTo(p2.x + centerX, p2.y + centerY);
            drawingContext.lineTo(p3.x + centerX, p3.y + centerY);
            drawingContext.closePath();
            drawingContext.fillStyle = 'rgba(128, 128, 128, 0.25)';
            drawingContext.fill();
        }

        function drawCutLines() {
            const triangles = [];

            for (let i = 0; i < outlinePoints.length; i++) {
                for (let j = 0; j < outlinePoints.length; j++) {
                    for (let k = 0; k < outlinePoints.length; k++) {
                        const p1 = outlinePoints[i];
                        const p2 = outlinePoints[j];
                        const p3 = outlinePoints[k];

                        if (p1.isConnected(p2) && p2.isConnected(p3) && p3.isConnected(p1)) {
                            triangles.push([p1, p2, p3]);
                        }
                    }
                }
            }

            for (let i = 0; i < triangles.length; i++) {
                for (let j = i + 1; j < triangles.length; j++) {
                    const sharedEdge = getSharedEdge(triangles[i], triangles[j]);
                    if (sharedEdge) {
                        const normal1 = calculateNormal(triangles[i]);
                        const normal2 = calculateNormal(triangles[j]);
                        if (!areNormalsParallel(normal1, normal2)) {
                            drawLine(sharedEdge[0], sharedEdge[1], 'red');
                        }
                    }
                }
            }
        }

        function getSharedEdge(triangle1, triangle2) {
            const sharedPoints = triangle1.filter(point => triangle2.includes(point) && !point.isCutWith(triangle2.find(p => p !== point)));
            if (sharedPoints.length === 2) {
                return sharedPoints;
            }
            return null;
        }

        function calculateNormal(triangle) {
            const [p1, p2, p3] = triangle;
            const u = { x: p2.x - p1.x, y: p2.y - p1.y, z: p2.z - p1.z };
            const v = { x: p3.x - p1.x, y: p3.y - p1.y, z: p3.z - p1.z };
            return {
                x: u.y * v.z - u.z * v.y,
                y: u.z * v.x - u.x * v.z,
                z: u.x * v.y - u.y * v.x
            };
        }

        function areNormalsParallel(normal1, normal2) {
            const dotProduct = normal1.x * normal2.x + normal1.y * normal2.y + normal1.z * normal2.z;
            const magnitude1 = Math.sqrt(normal1.x ** 2 + normal1.y ** 2 + normal1.z ** 2);
            const magnitude2 = Math.sqrt(normal2.x ** 2 + normal2.y ** 2 + normal2.z ** 2);
            const cosTheta = dotProduct / (magnitude1 * magnitude2);
            return Math.abs(cosTheta) > 0.999; // Treating both parallel and anti-parallel as parallel
        }

        function unfoldTriangles() {
            unfoldPoints = outlinePoints.map(point => new Point(point.x, point.y, point.z, point.isArc, point.selected, point.name, point.connectedPoints, point.isCutBetween));
            const triangles = [];

            for (let i = 0; i < unfoldPoints.length; i++) {
                for (let j = 0; j < unfoldPoints.length; j++) {
                    for (let k = 0; k < unfoldPoints.length; k++) {
                        const p1 = unfoldPoints[i];
                        const p2 = unfoldPoints[j];
                        const p3 = unfoldPoints[k];

                        if (p1.isConnected(p2) && p2.isConnected(p3) && p3.isConnected(p1)) {
                            triangles.push([p1, p2, p3]);
                        }
                    }
                }
            }

            const unfoldedTriangles = [];
            const placedPoints = new Set();

            triangles.forEach(triangle => {
                const [p1, p2, p3] = triangle;
                if (unfoldedTriangles.length === 0) {
                    unfoldedTriangles.push(triangle);
                    placedPoints.add(p1.name);
                    placedPoints.add(p2.name);
                    placedPoints.add(p3.name);
                } else {
                    const sharedEdge = getSharedEdgeWithUnfolded(triangle, unfoldedTriangles);
                    if (sharedEdge) {
                        const [sharedP1, sharedP2] = sharedEdge;
                        const newPoint = triangle.find(p => p !== sharedP1 && p !== sharedP2);
                        if (newPoint) {
                            const angle = calculateAngle(sharedP1, sharedP2, newPoint);
                            const newPosition = calculateNewPosition(sharedP1, sharedP2, newPoint, angle);
                            newPoint.updatePosition(newPosition.x, newPosition.y, newPosition.z);
                            unfoldedTriangles.push(triangle);
                            placedPoints.add(newPoint.name);
                        }
                    } else {
                        unfoldedTriangles.push(triangle);
                    }
                }
            });
            animateUnfolding(unfoldedTriangles);
        }

        function getSharedEdgeWithUnfolded(triangle, unfoldedTriangles) {
            for (const unfoldedTriangle of unfoldedTriangles) {
                const sharedEdge = getSharedEdge(triangle, unfoldedTriangle);
                if (sharedEdge) {
                    return sharedEdge;
                }
            }
            return null;
        }

        function calculateAngle(p1, p2, newPoint) {
            const a = calculateDistance(p1, p2);
            const b = calculateDistance(p2, newPoint);
            const c = calculateDistance(newPoint, p1);
            return Math.acos((b * b + c * c - a * a) / (2 * b * c));
        }

        function calculateNewPosition(p1, p2, newPoint, angle) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const dz = p2.z - p1.z;
            const distance = calculateDistance(p1, newPoint);
            const newX = p2.x + distance * Math.cos(angle);
            const newY = p2.y + distance * Math.sin(angle);
            const newZ = p2.z + distance * Math.sin(angle);
            return { x: newX, y: newY, z: newZ };
        }

        function animateUnfolding(unfoldedTriangles) {
            document.getElementById('unfoldingText').style.display = 'block';
            let iteration = 0;
            const maxIterations = 1000;

            function step() {
                let allNormalsAligned = true;

                unfoldedTriangles.forEach(triangle => {
                    const [p1, p2, p3] = triangle;
                    const normal = calculateNormal(triangle);
                    const parentTriangle = getParentTriangle(triangle, unfoldedTriangles);

                    if (parentTriangle) {
                        const parentNormal = calculateNormal(parentTriangle);
                        if (!areNormalsParallel(normal, parentNormal)) {
                            allNormalsAligned = false;
                            rotateTriangleTowardsParent(triangle, parentNormal, unfoldedTriangles);
                        }
                    }
                });

                if (!allNormalsAligned && iteration < maxIterations) {
                    iteration++;
                    requestAnimationFrame(step);
                } else {
                    document.getElementById('unfoldingText').style.display = 'none';
                    redrawUnfoldedTriangles(unfoldedTriangles);
                }
            }

            step();
        }

        function getParentTriangle(triangle, unfoldedTriangles) {
            for (const unfoldedTriangle of unfoldedTriangles) {
                if (unfoldedTriangle !== triangle) {
                    const sharedEdge = getSharedEdge(triangle, unfoldedTriangle);
                    if (sharedEdge) {
                        return unfoldedTriangle;
                    }
                }
            }
            return null;
        }

        function rotateTriangleTowardsParent(triangle, parentNormal, unfoldedTriangles) {
            const [p1, p2, p3] = triangle;
            const normal = calculateNormal(triangle);
            const angle = 1 * Math.PI / 180; // 1 degree in radians

            const rotationAxis = {
                x: normal.y * parentNormal.z - normal.z * parentNormal.y,
                y: normal.z * parentNormal.x - normal.x * parentNormal.z,
                z: normal.x * parentNormal.y - normal.y * parentNormal.x
            };

            const rotationMatrix = getRotationMatrix(rotationAxis, angle);

            applyRotation(p1, rotationMatrix);
            applyRotation(p2, rotationMatrix);
            applyRotation(p3, rotationMatrix);

            const connectedTriangles = getConnectedTriangles(triangle, unfoldedTriangles);
            connectedTriangles.forEach(connectedTriangle => {
                const [cp1, cp2, cp3] = connectedTriangle;
                applyRotation(cp1, rotationMatrix);
                applyRotation(cp2, rotationMatrix);
                applyRotation(cp3, rotationMatrix);
            });
        }

        function getConnectedTriangles(triangle, unfoldedTriangles) {
            const connectedTriangles = [];
            unfoldedTriangles.forEach(unfoldedTriangle => {
                if (unfoldedTriangle !== triangle) {
                    const sharedEdge = getSharedEdge(triangle, unfoldedTriangle);
                    if (sharedEdge) {
                        const normal = calculateNormal(triangle);
                        const unfoldedNormal = calculateNormal(unfoldedTriangle);
                        if (areNormalsParallel(normal, unfoldedNormal)) {
                            connectedTriangles.push(unfoldedTriangle);
                        }
                    }
                }
            });
            return connectedTriangles;
        }

        function getRotationMatrix(axis, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const t = 1 - cos;

            return [
                [t * axis.x * axis.x + cos, t * axis.x * axis.y - sin * axis.z, t * axis.x * axis.z + sin * axis.y],
                [t * axis.x * axis.y + sin * axis.z, t * axis.y * axis.y + cos, t * axis.y * axis.z - sin * axis.x],
                [t * axis.x * axis.z - sin * axis.y, t * axis.y * axis.z + sin * axis.x, t * axis.z * axis.z + cos]
            ];
        }

        function applyRotation(point, rotationMatrix) {
            const x = point.x;
            const y = point.y;
            const z = point.z;

            point.x = rotationMatrix[0][0] * x + rotationMatrix[0][1] * y + rotationMatrix[0][2] * z;
            point.y = rotationMatrix[1][0] * x + rotationMatrix[1][1] * y + rotationMatrix[1][2] * z;
            point.z = rotationMatrix[2][0] * x + rotationMatrix[2][1] * y + rotationMatrix[2][2] * z;
        }

        function redrawUnfoldedTriangles(unfoldedTriangles) {
            drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            unfoldedTriangles.forEach(triangle => {
                const [p1, p2, p3] = triangle;
                drawTriangle(p1, p2, p3);
            });

            unfoldPoints.forEach(point => {
                drawPoint(point);
                point.connectedPoints.forEach(connectedPointName => {
                    const connectedPoint = getPointByName(connectedPointName);
                    drawLine(point, connectedPoint);
                });
            });

            drawCutLines();
        }

const compareCoordinate = (a, b) => {
  if (a.x !== b.x) {
    return a.x - b.x;
  } else if (a.y !== b.y) {
    return a.y - b.y;
  } else {
    return a.z - b.z;
  }
};

        function areTrianglesEqual(triangle1, triangle2) {
            // 各三角形の頂点をソートして比較
console.log("triangle1 = ", triangle1);
console.log("triangle2 = ", triangle2);
            const sorted1 = triangle1.slice().sort(compareCoordinate);
            const sorted2 = triangle2.slice().sort(compareCoordinate);
console.log("sorted1 = ", sorted1);
console.log("sorted2 = ", sorted2);
            return sorted1[0] === sorted2[0] && sorted1[1] === sorted2[1] && sorted1[2] === sorted2[2];
        }

function getTrianglesSharingEdge(start, end) {
    const triangles = [];
console.log("unfoldPoints = ", unfoldPoints);
    for (let i = 0; i < unfoldPoints.length; i++) {
        for (let j = 0; j < unfoldPoints.length; j++) {
            for (let k = 0; k < unfoldPoints.length; k++) {
                const p1 = unfoldPoints[i];
                const p2 = unfoldPoints[j];
                const p3 = unfoldPoints[k];

                if (p1.isConnected(p2) && p2.isConnected(p3) && p3.isConnected(p1)) {
                    console.log("p1 = ", p1);
                    console.log("p2 = ", p2);
                    console.log("p3 = ", p3);
                    if ((p1.name === start.name && p2.name === end.name) || (p2.name === start.name && p3.name === end.name) || (p3.name === start.name && p1.name === end.name) ||
                        (p1.name === end.name && p2.name === start.name) || (p2.name === end.name && p3.name === start.name) || (p3.name === end.name && p1.name === start.name)) {

                        const newTriangle = [p1, p2, p3];
                        let isDuplicate = false;
                        console.log("newTriangle = ", newTriangle);
                        // 重複チェック
                        for (const existingTriangle of triangles) {
                            if (areTrianglesEqual(existingTriangle, newTriangle)) {
                                isDuplicate = true;
                                break;
                            }
                        }

                        if (!isDuplicate) {
                            triangles.push(newTriangle);
                        }
                    }
                }
            }
        }
    }
    return triangles;
}

        function rotateTrianglesToAlignNormals(triangles, start, end) {
            const [triangle1, triangle2] = triangles;
            const normal1 = calculateNormal(triangle1);
            const normal2 = calculateNormal(triangle2);

console.log("normal1 = ", normal1);
console.log("normal2 = ", normal2);

            if (!areNormalsParallel(normal1, normal2)) {
                const angle = 1 * Math.PI / 180; // 1 degree in radians
                const rotationAxis = {
                    x: normal1.y * normal2.z - normal1.z * normal2.y,
                    y: normal1.z * normal2.x - normal1.x * normal2.z,
                    z: normal1.x * normal2.y - normal1.y * normal2.x
                };

                const rotationMatrix = getRotationMatrix(rotationAxis, angle);

                applyRotation(triangle2[0], rotationMatrix);
                applyRotation(triangle2[1], rotationMatrix);
                applyRotation(triangle2[2], rotationMatrix);

                const connectedTriangles = getConnectedTriangles(triangle2, triangles);
                connectedTriangles.forEach(connectedTriangle => {
                    const [cp1, cp2, cp3] = connectedTriangle;
                    applyRotation(cp1, rotationMatrix);
                    applyRotation(cp2, rotationMatrix);
                    applyRotation(cp3, rotationMatrix);
                });

                requestAnimationFrame(() => rotateTrianglesToAlignNormals(triangles, start, end));
            } else {
                redrawCanvas();
            }
        }
    </script>
</body>
</html>
